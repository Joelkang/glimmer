// Generated by typings
// Source: https://raw.githubusercontent.com/DefinitelyTyped/DefinitelyTyped/7de6c3dd94feaeb21f20054b9f30d5dabc5efabd/handlebars/handlebars.d.ts
declare module 'handlebars' {
// Type definitions for Handlebars v3.0.3
// Project: http://handlebarsjs.com/
// Definitions by: Boris Yankov <https://github.com/borisyankov/>
// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped

import * as AST from "handlebars/ast";

namespace Handlebars {

    export function registerHelper(name: string, fn: Function, inverse?: boolean): void;
    export function registerHelper(name: Object): void;
    export function registerPartial(name: string, str: any): void;
    export function unregisterHelper(name: string): void;
    export function unregisterPartial(name: string): void;
    export function K(): void;
    export function createFrame(object: any): any;
    export function Exception(message: string): void;
    export function log(level: number, obj: any): void;
    export function parse(input: string): AST.Node;
    export function compile(input: any, options?: any): HandlebarsTemplateDelegate;

    export var SafeString: typeof hbs.SafeString;
    export var Utils: typeof hbs.Utils;
    export var logger: Logger;
    export var templates: HandlebarsTemplates;
    export var helpers: any;

    interface ICompiler {
        accept(node: AST.Node): void;
        Program(program: AST.Program): void;
        BlockStatement(block: AST.BlockStatement): void;
        PartialStatement(partial: AST.PartialStatement): void;
        MustacheStatement(mustache: AST.MustacheStatement): void;
        ContentStatement(content: AST.ContentStatement): void;
        CommentStatement(comment?: AST.CommentStatement): void;
        SubExpression(sexpr: AST.SubExpression): void;
        PathExpression(path: AST.PathExpression): void;
        StringLiteral(str: AST.StringLiteral): void;
        NumberLiteral(num: AST.NumberLiteral): void;
        BooleanLiteral(bool: AST.BooleanLiteral): void;
        UndefinedLiteral(): void;
        NullLiteral(): void;
        Hash(hash: AST.Hash): void;
    }

    export class Visitor implements ICompiler {
        accept(node: AST.Node): void;
        acceptKey(node: AST.Node, name: string): void;
        acceptArray(arr: AST.Expression[]): void;
        Program(program: AST.Program): void;
        BlockStatement(block: AST.BlockStatement): void;
        PartialStatement(partial: AST.PartialStatement): void;
        MustacheStatement(mustache: AST.MustacheStatement): void;
        ContentStatement(content: AST.ContentStatement): void;
        CommentStatement(comment?: AST.CommentStatement): void;
        SubExpression(sexpr: AST.SubExpression): void;
        PathExpression(path: AST.PathExpression): void;
        StringLiteral(str: AST.StringLiteral): void;
        NumberLiteral(num: AST.NumberLiteral): void;
        BooleanLiteral(bool: AST.BooleanLiteral): void;
        UndefinedLiteral(): void;
        NullLiteral(): void;
        Hash(hash: AST.Hash): void;
    }
}

/**
* Implement this interface on your MVW/MVVM/MVC views such as Backbone.View
**/
interface HandlebarsTemplatable {
    template: HandlebarsTemplateDelegate;
}

interface HandlebarsTemplateDelegate {
    (context: any, options?: any): string;
}

interface HandlebarsTemplates {
    [index: string]: HandlebarsTemplateDelegate;
}

namespace hbs {

    class SafeString {
        constructor(str: string);
        static toString(): string;
    }

    namespace Utils {
        function escapeExpression(str: string): string;
    }
}

interface Logger {
    DEBUG: number;
    INFO: number;
    WARN: number;
    ERROR: number;
    level: number;

    methodMap: { [level: number]: string };

    log(level: number, obj: string): void;
}

export { helpers } from "handlebars/ast";

export default Handlebars;

}

declare module "handlebars/ast" {

    export interface helpers {
        helperExpression(node: Node): boolean;
        scopeId(path: PathExpression): boolean;
        simpleId(path: PathExpression): boolean;
    }

    export interface Node {
        type: string;
        loc: SourceLocation;
    }

    export interface SourceLocation {
        source: string;
        start: Position;
        end: Position;
    }

    export interface Position {
        line: number;
        column: number;
    }

    export interface Program extends Node {
        body: Statement[];
        blockParams: string[];
    }

    export interface Statement extends Node {}

    export interface MustacheStatement extends Statement {
        path: PathExpression | Literal;
        params: Expression[];
        hash: Hash;
        escaped: boolean;
        strip: StripFlags;
    }

    export interface BlockStatement extends Statement {
        path: PathExpression;
        params: Expression[];
        hash: Hash;
        program: Program;
        inverse: Program;
        openStrip: StripFlags;
        inverseStrip: StripFlags;
        closeStrip: StripFlags;
    }

    export interface PartialStatement extends Statement {
        name: PathExpression | SubExpression;
        params: Expression[];
        hash: Hash;
        indent: string;
        strip: StripFlags;
    }

    export interface ContentStatement extends Statement {
        value: string;
        original: StripFlags;
    }

    export interface CommentStatement extends Statement {
        value: string;
        strip: StripFlags;
    }

    export interface Expression extends Node {}

    export interface SubExpression extends Expression {
        path: PathExpression;
        params: Expression[];
        hash: Hash;
    }

    export interface PathExpression extends Expression {
        data: boolean;
        depth: number;
        parts: string[];
        original: string;
    }

    export interface Literal extends Expression {}
    export interface StringLiteral extends Literal {
        value: string;
        original: string;
    }

    export interface BooleanLiteral extends Literal {
        value: boolean;
        original: boolean;
    }

    export interface NumberLiteral extends Literal {
        value: number;
        original: number;
    }

    export interface UndefinedLiteral extends Literal {}

    export interface NullLiteral extends Literal {}

    export interface Hash extends Node {
        pairs: HashPair[];
    }

    export interface HashPair extends Node {
        key: string;
        value: Expression;
    }

    export interface StripFlags {
        open: boolean;
        close: boolean;
    }
}
